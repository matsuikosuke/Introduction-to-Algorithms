# Introduction-to-Algorithms
Rust implementation of algorithms in the book "Introduction To Algorithms"


# 2.1 挿入ソート

挿入ソートは配列の数字を順番に並び替えるためのアルゴリズムです。

対象の配列の値を１つ前の配列の値と比較して、対象の配列より値が大きければ配列の順番を交換し、対象の配列より値が小さければそこで終了します。
この操作を、配列の2番目からn番目までを順に実行します。
必ず2番目から実行します。3番目以降から実行すると順番に並びません。

```rust
fn main() {
    let mut a: [i8; 6] = [4, 2, 6, 1, 3, 5];
    println!("{:?}", &a[0..6]);
    
    for j in 1..a.len() {
        let key = a[j];
        let mut i = j;
        
        while i>0 && a[i-1]>key
        {
            a[i] = a[i-1];
            i = i-1;
        }
        a[i] = key;
    }
    println!("{:?}", &a[0..6]);
}
```

https://play.rust-lang.org/ において実行すると、以下の結果を得ます。

```console
[4, 2, 6, 1, 3, 5]
[1, 2, 3, 4, 5, 6]
```

## A2.1-1

```rust
fn main() {
    let mut a: [i8; 6] = [31, 41, 59, 26, 41, 58];
    println!("{:?}", &a[0..6]);
    
    for j in 1..a.len() {
        let key = a[j];
        let mut i = j;
        
        while i>0 && a[i-1]>key
        {
            a[i] = a[i-1];
            i = i-1;
        }
        a[i] = key;
    }
    println!("{:?}", &a[0..6]);
}
```

## A2.1-2
対象の配列の値を１つ後の配列の値と比較して、対象の配列より値が大きければ配列の順番を交換し、対象の配列より値が小さければそこで終了します。
この操作を、配列のn-1番目から1番目までを順に実行します。
必ずn-1番目から実行します。

```rust
fn main() {
    let mut a: [i8; 6] = [31, 41, 59, 26, 41, 58];
    println!("{:?}", &a[0..6]);
    
    for j in (0..a.len()-1).rev() {
        let key = a[j];
        let mut i = j;
        while i<a.len()-1 && a[i+1]>key
        {
            a[i] = a[i+1];
            i = i+1;
        }
        a[i] = key;
        println!("{:?}", &a[0..6]);
    }
    println!("{:?}", &a[0..6]);
}
```

for文で逆順`rev()`を使用して配列の後ろから前方向に計算しています。

## A2.1-3

```rust
fn search(v: i8)-> usize {
    let a: [i8; 6] = [31, 41, 59, 26, 41, 58];
    println!("{:?}", &a[0..6]);
    
    for i in 0..a.len() {
        if a[i] == v
        {
            return i+1;
        }
    }
    
    return 0;
}

fn main()
{
    let v = 26;
    println!("{}は{}番目の値", v, search(v));
    
    let v = 100;
    println!("{}は{}番目の値", v, search(v));
}
```

## A2.1-4
この問題は、意味が分かりにくいですが、要は2進数の加算器についての問題です。

例えば、0b10011+0b10110という2進数の和を、２つの整数の配列、A[5] = [1, 1, 0, 0, 1]とB[5]=[0, 1, 1, 0, 1]で表現した上で、和を求めさせるものです。

```rust
fn main() {
    let a: [i8; 5] = [1, 1, 0, 0, 1];
    let b: [i8; 5] = [0, 1, 1, 0, 1];
    let mut c: [i8; 6] = [0, 0, 0, 0, 0, 0];
    println!("{:?}", &a[0..5]);
    println!("{:?}", &b[0..5]);
    
    let mut carry = 0;
    
    for i in (0..a.len()).rev() {
        c[i] = (a[i]+b[i]+carry)%2;
        carry = (a[i]+b[i]+carry)/2;
    }
    c[a.len()] = carry;
    c = c.rev();
    
    println!("{:?}", &c[0..a.len()+1]);
}
```
計算結果を以下に示します。
AとBのn-1番目同士の和を取り、繰上りがあれば、n番目同士の和に繰上りも可算していることが分かります。
0b10011+0b10110=0b101001を表しています。

```console
[1, 1, 0, 0, 1]
[0, 1, 1, 0, 1]
[1, 0, 0, 1, 0, 1]
```

本の通りにすれば、任意のn要素配列を代入できるようにしないといけませんが、アルゴリズムの本質とは関係ないので、こちらで用意した配列を代入しました。

# 2.2 アルゴリズムの解析

## 挿入ソートの解析

for文は、判定を何回行ったかを計算します。
`for j in 1..a.len()`は1からn-1までn-1回の判定に加え、、ループから抜ける際に1回の判定を行うので合計n回。

for文内で1回しか実行しない計算の計算回数はn-1回。
for文内での判定式は各ループ毎に判定回数が異なり、各ループで$t_j$回になる場合は、合計で$\sum_{j=1}^{n-1} t_j$回。
for文内での判定式において実行される計算は、ループから抜ける1回の判定回数を除いて、計算回数×$(t_j-1)$回になります。挿入ソートでは計算回数は1回なので合計で$\sum_{j=1}^{n-1} t_j$回。

最良の条件は、初めからソートされている場合であり、while以下の計算が0になります。

最悪の条件は、初めから逆順にソートされている場合であり、while以下の計算がkeyの添え字より小さい数字の添え字の全てについて計算しないといけないので、$t_j=j$となります。

## A2.2-1
計算量の次元は最大次数の項のみが影響するので、

```math
\begin{eqnarray}
n^3/1000 \in \Theta(n^3)
\end{eqnarray}
```

となります。

## A2.2-2
配列の1番目の要素を2番目からn番目の要素と比較し、最小の要素と1番目の要素を交換します。
配列の2番目の要素を3番目からn番目の要素と比較し、最小の要素と2番目の要素を交換します。
...
配列のn-2番目の要素をn-1番目からn番目の要素と比較し、最小の要素とn-2番目の要素を交換します。
配列のn-1番目の要素をn番目の要素と比較し、最小の要素とn-1番目の要素を交換します。

for loopはn-1番目まで実行すれば、残りのn番目の要素は必ず最大値なので、n個全ての要素について実行する必要はありません。

```rust
fn main() {
    let mut a: [i8; 6] = [4, 2, 6, 1, 3, 5];
    println!("{:?}", &a[0..6]);
    
    for j in 0..a.len()-1 {
        let mut key = j;
        let mut min = a[key];
        
        for i in j+1..a.len() {
            if min >  a[i]
            {
                key = i;
                min = a[i];
            }
        }
        a[key] = a[j];
        a[j] = min;
    }
    println!("{:?}", &a[0..6]);
}
```

計算量は、

`for j in 0..a.len()-1`が、要素数n-1回とloopを抜ける判定の1回で$n-1+1=n$回。
`let mut key = j;`がn-1回。
`let mut min = a[key];`がn-1回。
`for i in j+1..a.len()`が、各ループ毎に、要素数n-j-1回とloopを抜ける判定の1回で$n-j-1+1=n-j$ 回。その総和で$\sum_{j=0}^{n-1}(n-j)$
`if min >  a[i]`が各ループ毎に、n-j-1回。その総和で$\sum_{j=0}^{n-1}(n-j-1)$回。
`key = i;`が各ループ毎に、n-j-1回。その総和で$\sum_{j=0}^{n-1}(n-j-1)$回。
`min = a[i];`が各ループ毎に、n-j-1回。その総和で$\sum_{j=0}^{n-1}(n-j-1)$回。
`a[key] = a[j];`がn-1回。
`a[j] = min;`がn-1回。


最良の条件は、初めからソートされている場合であり、`key = i;`と`min = a[i];`の計算が0になります。

最悪の条件は、初めから逆順にソートされている場合であり、`key = i;`と`min = a[i];`の計算を毎回しないといけません。

ですが、最良の場合も、最悪の場合も、必ず`for i in j+1..a.len()`と`if min >  a[i]`の計算を実行するので、どちらの場合でも計算の次元は$\Theta(n^2)$になります。

```math
\begin{eqnarray}
\sum_{j=0}^{n-1}(n-j-1) &=& \frac{((n-0-1)+(n-n+1-1))*n}{2} \\
&=& \frac{(n-1)*n}{2} 
\end{eqnarray}
```

直観的に考えると、挿入式は配列の並び方の運が良いと途中でループから抜け出ることができ、選択式はどんな配列でも全部比較しないといけないのでループを最後まで抜け出せないという違いです。


## A2.2-3

挿入ソートのアルゴリズムについて、配列要素に同じ数字がある場合の計算量の違いを比較する問題です。
配列内に同じ数字があれば、keyの数字が同じ数字と比較した時点でループから抜けて、`while i>0 && a[i-1]>key`以下を実行しないで済むので、それだけ計算量が減ります。

最良の場合は配列の要素が全て同じ数字の場合で、最初からソートされている場合と同じ計算量になります。
最悪の場合は配列の要素が全て異なる場合です。

例えば、配列が[3,1,2,1,1,2,4,1,5,2]だった場合を考えます。
最初に1をkeyにして比較している時、`while i>0 && a[i-1]>key`以下の計算を1回も省略できません。
次に2をkeyにして比較している時、`while i>0 && a[i-1]>key`以下の計算を1回も省略できません。
次に1をkeyにして比較している時、3回目の比較対象に1が来た時点で、`while i>0 && a[i-1]>key`以下の計算を省略できます。
次に1をkeyにして比較している時、3回目の比較対象に1が来た時点で、`while i>0 && a[i-1]>key`以下の計算を省略できます。

つまり計算量は、配列内に同じ要素が幾つあるか、そしてその要素が比較対象になるかどうかに影響されます。
この２つの条件を満たす確率は、上記の例のように、短い配列だと確率の差が大きいでしょうが、膨大な長さのランダムな配列ならば一定の確率（1/10）に収束すると思われます。
これが問題文中で「探索すべき要素が配列中の任意の要素と等確率で一致する」と表現されていることです。
この確率を$p$とします。


keyの要素との比較が、1回目で一致して終了する確率、2回目で一致して終了する確率、3回目で一致して終了する確率、...、(n-1)回目で一致して終了する確率、そして最後まで一致しない場合の、計算回数の期待値の総和を求めます。

まずkeyの要素を$j$個の要素と比較することになる確率を考えます。こうなる確率は$j-1$回は一致せず、1回一致したということなので、一致しない確率の(j-1)乗と一致する確率の積、$(1-p)^{j-1}*p$ です。

この時の計算回数の期待値は、j回の計算をしているので、$j*(1-p)^{j-1}*p$です。

またkeyの要素がn-1回の計算で1回も一致しない確率は$(1-p)^{n-1}$です。計算回数の期待値は$n-1$回の計算をしているので、$(n-1)*(1-p)^{n-1}$です。

よって期待値の総和は、

```math
\begin{eqnarray}
計算回数の期待値 
&=& (n-1)*(1-p)^{n-1} + \sum_{j=1}^{n-1} j*(1-p)^{j-1}*p \\
&=& (n-1)*(1-p)^{n-1} + \sum_{i=1}^{n-1} \sum_{j=i}^{n-1} (1-p)^{j-1}*p \\
&=& (n-1)*(1-p)^{n-1} + \sum_{i=1}^{n-1}  \frac{(1-p)^{i-1} - (1-p)^{n-1}}{1-(1-p)} *p \\
&=& (n-1)* (1-p)^{n-1} + \sum_{i=1}^{n-1}  \Bigl((1-p)^{i-1} - (1-p)^{n-1} \Bigl) \\
&=& (n-1)* (1-p)^{n-1} + \sum_{i=1}^{n-1}  (1-p)^{i-1} - (n-1)* (1-p)^{n-1} \\
&=& \frac{1 - (1-p)^{n-1}}{1-(1-p)} \\
&=& \frac{1}{p} - \frac{(1-p)^{n-1}}{p} \\
\end{eqnarray}
```

です。つまり、これが問題文中の「入力列の中で調べられる要素数の平均」です。
この期待値の計算量の次元は$\Theta(1)$です。

## A2.2-4

挿入ソートの事例を見れば、可能な限り条件判定を早めに終わらせ、ループを抜け出して終了できるアルゴリズムが最良実行時間を持つアルゴリズムと言えそうです。

